generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}



model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String
  name         String?
  role         String    @default("ADMIN")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  conversations Conversation[]
  messages      Message[]
  sessions      Session[]
}

model Category {
  id            String     @id @default(cuid())
  name          String
  slug          String     @unique
  icon          String?    // URL or icon name
  image         String?    // For visual representation
  parentId      String?
  parent        Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      Category[] @relation("CategoryHierarchy")
  products      Product[]
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
}

model Product {
  id            String   @id @default(cuid())
  name          String
  supplier      String?
  description   String?
  price         Decimal?
  minOrder      String?
  categoryId    String
  category      Category @relation(fields: [categoryId], references: [id])
  brandId       String?
  brand         Brand?   @relation(fields: [brandId], references: [id])
  images        String[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Brand {
  id          String    @id @default(cuid())
  name        String
  slug        String    @unique
  logo        String?
  banner      String?
  description String?
  verified    Boolean   @default(false)
  products    Product[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  conversations Conversation[]
}

model Banner {
  id            String   @id @default(cuid())
  title         String?
  image         String
  link          String?
  subCategoryId String
  active        Boolean  @default(true)
  expiresAt     DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}



model Conversation {
  id        String   @id @default(cuid())
  
  // Participants
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  brandId   String
  brand     Brand    @relation(fields: [brandId], references: [id])
  
  messages  Message[]
  
  // Performance Optimization for Inbox (Denormalization)
  lastMessageAt DateTime @default(now()) // Index นี้สำคัญมากสำหรับการ sort inbox
  lastMessage   String?  // Snippet
  
  // Read Status counters (Better than isRead per message)
  userLastReadAt  DateTime @default(now())
  brandLastReadAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes
  @@unique([userId, brandId]) // 1 User : 1 Brand per conversation
  @@index([userId, lastMessageAt(sort: Desc)]) // For fetching User's inbox
  @@index([brandId, lastMessageAt(sort: Desc)]) // For fetching Brand's inbox
}

model Message {
  id             String       @id @default(cuid())
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  senderId       String       // Foreign Key to User (for integrity)
  sender         User         @relation(fields: [senderId], references: [id])
  senderType     SenderType   // USER or BRAND
  
  content        String
  
  createdAt      DateTime     @default(now())

  @@index([conversationId, createdAt(sort: Asc)]) // For fetching chat history
}

enum SenderType {
  USER
  BRAND
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}
